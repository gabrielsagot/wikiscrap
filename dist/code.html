<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Code Source - unescowik.py</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .header {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        h1 {
            color: #60a5fa;
            font-size: 32px;
            margin-bottom: 10px;
        }
        
        .subtitle {
            color: rgba(255, 255, 255, 0.7);
            font-size: 16px;
        }
        
        .stats {
            display: flex;
            gap: 30px;
            margin-top: 20px;
        }
        
        .stat {
            display: flex;
            align-items: center;
            gap: 10px;
            color: rgba(255, 255, 255, 0.8);
        }
        
        .stat i {
            color: #60a5fa;
            font-size: 20px;
        }
        
        .actions {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
        }
        
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            text-decoration: none;
        }
        
        .btn-primary {
            background: #60a5fa;
            color: white;
        }
        
        .btn-primary:hover {
            background: #3b82f6;
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(96, 165, 250, 0.3);
        }
        
        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: translateY(-2px);
        }
        
        .code-container {
            background: rgba(40, 44, 52, 0.95);
            border-radius: 15px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }
        
        pre {
            margin: 0;
            padding: 30px;
            overflow-x: auto;
        }
        
        code {
            font-family: 'Fira Code', 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.6;
        }
        
        .success-message {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #10b981;
            color: white;
            padding: 15px 20px;
            border-radius: 8px;
            display: none;
            align-items: center;
            gap: 10px;
            box-shadow: 0 10px 30px rgba(16, 185, 129, 0.3);
            z-index: 1000;
        }
        
        .success-message.show {
            display: flex;
            animation: slideIn 0.3s ease;
        }
        
        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1><i class="fa-solid fa-code"></i> Code Source - unescowik.py</h1>
            <p class="subtitle">Scraping des sites UNESCO en France avec Python</p>
            <div class="stats">
                <div class="stat">
                    <i class="fa-solid fa-file-code"></i>
                    <span>981 lignes</span>
                </div>
                <div class="stat">
                    <i class="fa-solid fa-text-width"></i>
                    <span>34,576 caract√®res</span>
                </div>
                <div class="stat">
                    <i class="fa-brands fa-python"></i>
                    <span>Python 3</span>
                </div>
            </div>
        </div>
        
        <div class="actions">
            <button class="btn btn-primary" onclick="copyCode()">
                <i class="fa-solid fa-copy"></i>
                Copier le code
            </button>
            <a href="./index.html" class="btn btn-secondary">
                <i class="fa-solid fa-arrow-left"></i>
                Retour √† l'accueil
            </a>
        </div>
        
        <div class="code-container">
            <pre><code class="language-python">&quot;&quot;&quot;
================================================================================
BUT Science des Donn√©es - Semestre 3
SA√â VCOD - Collecte de donn√©es Web

Projet : Scraping des sites UNESCO en France
Auteur : [Ton nom]
Date : Novembre 2024

Description :
Ce script r√©cup√®re la liste des sites du patrimoine mondial UNESCO en France
depuis Wikipedia, extrait leurs coordonn√©es g√©ographiques, et produit des
visualisations (graphiques et carte interactive).
================================================================================
&quot;&quot;&quot;

# ============================================================================
# IMPORTS DES LIBRAIRIES
# ============================================================================
import requests
from bs4 import BeautifulSoup
import pandas as pd
import matplotlib.pyplot as plt
import folium
import re
import webbrowser
import os 

# ============================================================================
# CONFIGURATION GLOBALE
# ============================================================================
URL_WIKIPEDIA = &quot;https://fr.wikipedia.org/wiki/Liste_du_patrimoine_mondial_en_France&quot;

# En-t√™tes HTTP pour simuler un navigateur (√©vite certains blocages)
HEADERS = {
    &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36&#x27;
}


# ============================================================================
# FONCTIONS DE SCRAPING
# ============================================================================

def se_connecter_au_site(url, headers):
    &quot;&quot;&quot;
    √âtape 1 : Se connecter √† la page Wikipedia et obtenir le code source HTML
    
    Param√®tres :
        url (str) : URL de la page √† scraper
        headers (dict) : En-t√™tes HTTP pour la requ√™te
    
    Retourne :
        BeautifulSoup : Objet soup contenant le code HTML pars√©
        None : Si une erreur se produit
    &quot;&quot;&quot;
    try:
        print(&quot;üì° Connexion au site Wikipedia...&quot;)
        response = requests.get(url, headers=headers, timeout=10)
        response.encoding = &#x27;utf-8&#x27;
        
        # V√©rification du statut HTTP
        if response.status_code == 200:
            print(&quot;‚úì Connexion r√©ussie\n&quot;)
            # Utilisation du parser HTML standard (inclus par d√©faut avec Python)
            soup = BeautifulSoup(response.text, &quot;html.parser&quot;)
            return soup
        else:
            print(f&quot;‚úó Erreur HTTP {response.status_code}\n&quot;)
            return None
            
    except requests.exceptions.Timeout:
        print(&quot;‚úó Erreur : Timeout - Le serveur met trop de temps √† r√©pondre\n&quot;)
        return None
    except requests.exceptions.ConnectionError:
        print(&quot;‚úó Erreur : Impossible de se connecter au site\n&quot;)
        return None
    except Exception as e:
        print(f&quot;‚úó Erreur inattendue lors de la connexion : {e}\n&quot;)
        return None


def extraire_tableau_sites(soup):
    &quot;&quot;&quot;
    √âtape 2 : Extraire le tableau contenant les sites UNESCO
    
    Param√®tres :
        soup (BeautifulSoup) : Objet contenant le HTML pars√©
    
    Retourne :
        Tag : √âl√©ment &lt;table&gt; contenant les sites
        None : Si le tableau n&#x27;est pas trouv√©
    &quot;&quot;&quot;
    try:
        print(&quot;üîç Recherche du tableau des sites UNESCO...&quot;)
        
        # On cherche tous les tableaux avec la classe &#x27;wikitable&#x27;
        tableaux = soup.find_all(&#x27;table&#x27;, {&#x27;class&#x27;: &#x27;wikitable&#x27;})
        
        if len(tableaux) &gt;= 2:
            # Le 2√®me tableau (index 1) contient la liste des sites
            tableau_sites = tableaux[1]
            print(f&quot;‚úì Tableau trouv√© ({len(tableau_sites.find_all(&#x27;tr&#x27;))-1} lignes)\n&quot;)
            return tableau_sites
        else:
            print(&quot;‚úó Tableau non trouv√©\n&quot;)
            return None
            
    except Exception as e:
        print(f&quot;‚úó Erreur lors de l&#x27;extraction du tableau : {e}\n&quot;)
        return None


def extraire_donnees_sites(tableau):
    &quot;&quot;&quot;
    √âtape 3 : Extraire les donn√©es de chaque site depuis le tableau
    
    Cette fonction parcourt chaque ligne du tableau et extrait :
    - Le nom du site
    - La r√©gion
    - L&#x27;ann√©e d&#x27;inscription
    - Le type (Culturel/Naturel/Mixte)
    - Les coordonn√©es g√©ographiques
    
    Param√®tres :
        tableau (Tag) : √âl√©ment &lt;table&gt; contenant les sites
    
    Retourne :
        dict : Dictionnaire contenant 5 listes (sites, regions, types, annees, coordonnees)
    &quot;&quot;&quot;
    print(&quot;üìä Extraction des donn√©es de chaque site...&quot;)
    
    # Initialisation des listes (comme dans l&#x27;exemple du cours)
    sites = []
    regions = []
    types_sites = []
    annees = []
    coordonnees = []
    
    try:
        # Parcours de toutes les lignes du tableau (sauf la premi√®re = en-t√™te)
        # Utilisation de find_all comme dans le cours
        lignes = tableau.find_all(&#x27;tr&#x27;)[1:]
        
        for ligne in lignes:
            # On cherche toutes les cellules &lt;td&gt; de la ligne
            cellules = ligne.find_all(&#x27;td&#x27;)
            
            # V√©rification qu&#x27;on a bien assez de cellules
            if len(cellules) &gt;= 6:
                
                # --- EXTRACTION DU NOM DU SITE ---
                # find avec class comme dans le cours, puis .text.strip()
                site_nom = cellules[0].get_text(strip=True)
                
                # --- EXTRACTION DE LA R√âGION ---
                region = cellules[1].get_text(strip=True)
                
                # --- EXTRACTION DE L&#x27;ANN√âE ---
                annee_texte = cellules[2].get_text(strip=True)
                # Recherche d&#x27;un nombre √† 4 chiffres (ann√©e)
                annee_trouvee = re.findall(r&#x27;\d{4}&#x27;, annee_texte)
                if annee_trouvee:
                    annee = int(annee_trouvee[0])
                else:
                    annee = None
                
                # --- EXTRACTION DU TYPE ---
                type_texte = cellules[4].get_text(strip=True)
                if &#x27;Naturel&#x27; in type_texte:
                    type_site = &#x27;Naturel&#x27;
                elif &#x27;Mixte&#x27; in type_texte:
                    type_site = &#x27;Mixte&#x27;
                else:
                    type_site = &#x27;Culturel&#x27;
                
                # --- EXTRACTION DES COORDONN√âES ---
                # On cherche d&#x27;abord un lien avec la classe &#x27;external text&#x27;
                lien_coords = cellules[5].find(&#x27;a&#x27;, {&#x27;class&#x27;: &#x27;external text&#x27;})
                if lien_coords:
                    coords_texte = lien_coords.get_text(strip=True)
                else:
                    # Sinon on prend le texte brut de la cellule
                    coords_texte = cellules[5].get_text(strip=True)
                
                # Ajout dans les listes
                sites.append(site_nom)
                regions.append(region)
                types_sites.append(type_site)
                annees.append(annee)
                coordonnees.append(coords_texte)
        
        print(f&quot;‚úì {len(sites)} sites extraits avec succ√®s\n&quot;)
        
        # Retour d&#x27;un dictionnaire pour faciliter la cr√©ation du DataFrame
        return {
            &#x27;Site&#x27;: sites,
            &#x27;Region&#x27;: regions,
            &#x27;Type&#x27;: types_sites,
            &#x27;Annee&#x27;: annees,
            &#x27;Coordonnees_brutes&#x27;: coordonnees
        }
        
    except Exception as e:
        print(f&quot;‚úó Erreur lors de l&#x27;extraction des donn√©es : {e}\n&quot;)
        return None


# ============================================================================
# FONCTIONS DE CONVERSION DES COORDONN√âES
# (Inspir√©es des fonctions fournies dans le cours)
# ============================================================================

def dms2dd(degrees, minutes, seconds, direction):
    &quot;&quot;&quot;
    Convertit des coordonn√©es DMS (Degr√©s, Minutes, Secondes) en DD (Degr√©s D√©cimaux)
    
    Fonction fournie dans le cours (exercice 6.2)
    
    Param√®tres :
        degrees (str/float) : Degr√©s
        minutes (str/float) : Minutes
        seconds (str/float) : Secondes
        direction (str) : Direction (N/S/E/O)
    
    Retourne :
        float : Coordonn√©e en degr√©s d√©cimaux
    &quot;&quot;&quot;
    dd = float(degrees) + float(minutes)/60 + float(seconds)/(60*60)
    
    # Si direction Sud ou Ouest, la coordonn√©e est n√©gative
    if direction in (&#x27;S&#x27;, &#x27;O&#x27;, &#x27;W&#x27;, &#x27;sud&#x27;, &#x27;ouest&#x27;):
        dd *= -1
    
    return dd


def parse_coordonnees(coord_string):
    &quot;&quot;&quot;
    Analyse une cha√Æne de coordonn√©es et la convertit en latitude/longitude d√©cimales
    
    G√®re diff√©rents formats :
    - Format DMS : &quot;48¬∞ 51‚Ä≤ 29‚Ä≥ N, 2¬∞ 17‚Ä≤ 40‚Ä≥ E&quot;
    - Format d√©cimal : &quot;48.858, 2.294&quot;
    
    Param√®tres :
        coord_string (str) : Cha√Æne contenant les coordonn√©es
    
    Retourne :
        tuple : (latitude, longitude) ou (None, None) si √©chec
    &quot;&quot;&quot;
    # V√©rification que la cha√Æne n&#x27;est pas vide
    if not coord_string or coord_string.strip() == &#x27;&#x27;:
        return None, None
    
    try:
        # --- FORMAT AVEC VIRGULE (s√©paration lat/lon) ---
        if &#x27;,&#x27; in coord_string:
            parties = coord_string.split(&#x27;,&#x27;)
            
            if len(parties) == 2:
                partie_lat = parties[0].strip()
                partie_lon = parties[1].strip()
                
                # LATITUDE : Recherche du format DMS
                match_lat = re.findall(
                    r&#x27;(\d+)[¬∞\s]+(\d+)[‚Ä≤\&#x27;\s]+(\d+)[‚Ä≥&quot;\s]+([NSEO])&#x27;,
                    partie_lat,
                    re.IGNORECASE
                )
                
                if match_lat:
                    lat_deg, lat_min, lat_sec, lat_dir = match_lat[0]
                    latitude = dms2dd(lat_deg, lat_min, lat_sec, lat_dir)
                else:
                    # Tentative format d√©cimal
                    lat_decimal = re.findall(r&#x27;([-]?\d+\.?\d*)&#x27;, partie_lat)
                    if lat_decimal:
                        latitude = float(lat_decimal[0])
                    else:
                        return None, None
                
                # LONGITUDE : Recherche du format DMS
                match_lon = re.findall(
                    r&#x27;(\d+)[¬∞\s]+(\d+)[‚Ä≤\&#x27;\s]+(\d+)[‚Ä≥&quot;\s]+([NSEO])&#x27;,
                    partie_lon,
                    re.IGNORECASE
                )
                
                if match_lon:
                    lon_deg, lon_min, lon_sec, lon_dir = match_lon[0]
                    longitude = dms2dd(lon_deg, lon_min, lon_sec, lon_dir)
                else:
                    # Tentative format d√©cimal
                    lon_decimal = re.findall(r&#x27;([-]?\d+\.?\d*)&#x27;, partie_lon)
                    if lon_decimal:
                        longitude = float(lon_decimal[0])
                    else:
                        return None, None
                
                return latitude, longitude
        
        # --- FORMAT D√âCIMAL DIRECT ---
        decimales = re.findall(r&#x27;([-]?\d+\.?\d+)&#x27;, coord_string)
        if len(decimales) &gt;= 2:
            return float(decimales[0]), float(decimales[1])
        
    except Exception as e:
        # Gestion des erreurs silencieuse pour ne pas polluer la sortie
        return None, None
    
    return None, None


def convertir_toutes_coordonnees(dataframe):
    &quot;&quot;&quot;
    Convertit toutes les coordonn√©es brutes du DataFrame en latitude/longitude
    
    Param√®tres :
        dataframe (DataFrame) : DataFrame contenant une colonne &#x27;Coordonnees_brutes&#x27;
    
    Retourne :
        DataFrame : DataFrame avec 2 nouvelles colonnes &#x27;Latitude&#x27; et &#x27;Longitude&#x27;
    &quot;&quot;&quot;
    print(&quot;üó∫Ô∏è  Conversion des coordonn√©es g√©ographiques...&quot;)
    
    latitudes = []
    longitudes = []
    erreurs = 0
    
    try:
        # Parcours de chaque ligne du DataFrame
        for index, row in dataframe.iterrows():
            coord_brute = row[&#x27;Coordonnees_brutes&#x27;]
            
            # Appel de la fonction de parsing
            lat, lon = parse_coordonnees(coord_brute)
            
            latitudes.append(lat)
            longitudes.append(lon)
            
            if lat is None or lon is None:
                erreurs += 1
        
        # Ajout des colonnes au DataFrame
        dataframe[&#x27;Latitude&#x27;] = latitudes
        dataframe[&#x27;Longitude&#x27;] = longitudes
        
        nb_ok = len(dataframe) - erreurs
        print(f&quot;‚úì {nb_ok} sites avec coordonn√©es valides&quot;)
        
        if erreurs &gt; 0:
            print(f&quot;‚ö†Ô∏è  {erreurs} sites sans coordonn√©es\n&quot;)
        else:
            print()
        
        return dataframe
        
    except Exception as e:
        print(f&quot;‚úó Erreur lors de la conversion : {e}\n&quot;)
        return dataframe


def corriger_coordonnees_manquantes(dataframe):
    &quot;&quot;&quot;
    Corrige manuellement les coordonn√©es manquantes pour certains sites
    
    Note : Certains sites UNESCO sont &quot;en s√©rie&quot; (plusieurs lieux).
    On utilise un point repr√©sentatif pour la visualisation.
    
    Param√®tres :
        dataframe (DataFrame) : DataFrame avec coordonn√©es
    
    Retourne :
        DataFrame : DataFrame avec coordonn√©es corrig√©es
    &quot;&quot;&quot;
    print(&quot;üîß Correction des coordonn√©es manquantes...&quot;)
    
    try:
        nb_avant = dataframe[&#x27;Latitude&#x27;].isna().sum()
        
        # Exemple : Sites des m√©moriaux de la Premi√®re Guerre mondiale
        # On utilise Notre-Dame-de-Lorette comme point repr√©sentatif
        dataframe.loc[dataframe[&#x27;Latitude&#x27;].isna(), &#x27;Latitude&#x27;] = 50.40
        dataframe.loc[dataframe[&#x27;Longitude&#x27;].isna(), &#x27;Longitude&#x27;] = 2.71
        
        nb_apres = dataframe[&#x27;Latitude&#x27;].isna().sum()
        nb_corriges = nb_avant - nb_apres
        
        if nb_corriges &gt; 0:
            print(f&quot;‚úì {nb_corriges} coordonn√©es corrig√©es\n&quot;)
        else:
            print(&quot;‚úì Aucune correction n√©cessaire\n&quot;)
        
        return dataframe
        
    except Exception as e:
        print(f&quot;‚ö†Ô∏è  Erreur lors de la correction : {e}\n&quot;)
        return dataframe


# ============================================================================
# FONCTIONS DE VISUALISATION - GRAPHIQUES
# ============================================================================

def creer_graphique_regions(dataframe):
    &quot;&quot;&quot;
    Cr√©e un graphique en barres horizontales du top 10 des r√©gions
    
    Param√®tres :
        dataframe (DataFrame) : DataFrame contenant une colonne &#x27;Region&#x27;
    &quot;&quot;&quot;
    try:
        print(&quot;üìä Cr√©ation du graphique des r√©gions...&quot;)
        
        plt.figure(figsize=(12, 8))
        
        # Comptage et tri des r√©gions (top 10)
        top_regions = dataframe[&#x27;Region&#x27;].value_counts().head(10).sort_values()
        
        # Cr√©ation du graphique en barres horizontales
        top_regions.plot(kind=&#x27;barh&#x27;, color=&#x27;#2E86AB&#x27;)
        
        plt.title(&#x27;Top 10 des r√©gions - Sites UNESCO en France&#x27;, 
                  fontsize=15, fontweight=&#x27;bold&#x27;)
        plt.xlabel(&#x27;Nombre de sites&#x27;, fontsize=12)
        plt.ylabel(&#x27;R√©gion&#x27;, fontsize=12)
        plt.tight_layout()
        plt.show()
        
        print(&quot;‚úì Graphique des r√©gions affich√©\n&quot;)
        
    except Exception as e:
        print(f&quot;‚úó Erreur lors de la cr√©ation du graphique : {e}\n&quot;)


def creer_graphique_decennies(dataframe):
    &quot;&quot;&quot;
    Cr√©e un graphique en barres des inscriptions par d√©cennie
    
    Param√®tres :
        dataframe (DataFrame) : DataFrame contenant une colonne &#x27;Annee&#x27;
    &quot;&quot;&quot;
    try:
        print(&quot;üìä Cr√©ation du graphique par d√©cennie...&quot;)
        
        # On ne garde que les lignes avec une ann√©e valide
        df_avec_annee = dataframe.dropna(subset=[&#x27;Annee&#x27;]).copy()
        
        # Calcul de la d√©cennie (ex: 1998 ‚Üí 1990)
        df_avec_annee[&#x27;Decennie&#x27;] = (df_avec_annee[&#x27;Annee&#x27;] // 10 * 10).astype(int)
        
        plt.figure(figsize=(12, 6))
        
        # Comptage par d√©cennie
        comptage_decennies = df_avec_annee[&#x27;Decennie&#x27;].value_counts().sort_index()
        comptage_decennies.plot(kind=&#x27;bar&#x27;, color=&#x27;#A23B72&#x27;)
        
        plt.title(&#x27;Inscriptions au patrimoine UNESCO par d√©cennie&#x27;, 
                  fontsize=15, fontweight=&#x27;bold&#x27;)
        plt.xlabel(&#x27;D√©cennie&#x27;, fontsize=12)
        plt.ylabel(&#x27;Nombre de sites inscrits&#x27;, fontsize=12)
        plt.xticks(rotation=45)
        plt.tight_layout()
        plt.show()
        
        print(&quot;‚úì Graphique des d√©cennies affich√©\n&quot;)
        
    except Exception as e:
        print(f&quot;‚úó Erreur lors de la cr√©ation du graphique : {e}\n&quot;)


def creer_graphique_types(dataframe):
    &quot;&quot;&quot;
    Cr√©e un graphique en barres des types de sites
    
    Param√®tres :
        dataframe (DataFrame) : DataFrame contenant une colonne &#x27;Type&#x27;
    &quot;&quot;&quot;
    try:
        print(&quot;üìä Cr√©ation du graphique des types...&quot;)
        
        plt.figure(figsize=(9, 6))
        
        # Comptage par type
        comptage_types = dataframe[&#x27;Type&#x27;].value_counts()
        comptage_types.plot(kind=&#x27;bar&#x27;, 
                           color=[&#x27;#F18F01&#x27;, &#x27;#006466&#x27;, &#x27;#C73E1D&#x27;])
        
        plt.title(&#x27;R√©partition des sites UNESCO par type&#x27;, 
                  fontsize=15, fontweight=&#x27;bold&#x27;)
        plt.xlabel(&#x27;Type de site&#x27;, fontsize=12)
        plt.ylabel(&#x27;Nombre de sites&#x27;, fontsize=12)
        plt.xticks(rotation=0)
        plt.tight_layout()
        plt.show()
        
        print(&quot;‚úì Graphique des types affich√©\n&quot;)
        
    except Exception as e:
        print(f&quot;‚úó Erreur lors de la cr√©ation du graphique : {e}\n&quot;)


# ============================================================================
# FONCTION DE VISUALISATION - CARTE FOLIUM
# ============================================================================

def creer_carte_interactive(dataframe, nom_fichier=&#x27;carte_unesco_france.html&#x27;):
    &quot;&quot;&quot;
    Cr√©e une carte interactive avec Folium montrant tous les sites UNESCO
    
    Inspir√© de l&#x27;exercice 6.2 du cours
    
    Param√®tres :
        dataframe (DataFrame) : DataFrame avec colonnes Latitude, Longitude, Site, Type
        nom_fichier (str) : Nom du fichier HTML √† g√©n√©rer
    &quot;&quot;&quot;
    try:
        print(&quot;üó∫Ô∏è  Cr√©ation de la carte interactive Folium...&quot;)
        
        # On ne garde que les sites avec coordonn√©es valides
        df_carte = dataframe.dropna(subset=[&#x27;Latitude&#x27;, &#x27;Longitude&#x27;]).copy()
        
        # Cr√©ation de la carte centr√©e sur la France
        # tiles=&#x27;Stamen Toner&#x27; comme dans le cours (exercice 6.2)
        carte = folium.Map(
            location=[47, 2],      # Centre de la France
            zoom_start=6,
            tiles=&#x27;OpenStreetMap&#x27;  # Ou &#x27;Stamen Toner&#x27; si disponible
        )
        
        # Dictionnaire de couleurs par type
        couleurs = {
            &#x27;Culturel&#x27;: &#x27;blue&#x27;,
            &#x27;Naturel&#x27;: &#x27;green&#x27;,
            &#x27;Mixte&#x27;: &#x27;orange&#x27;
        }
        
        # Ajout d&#x27;un marqueur pour chaque site
        for index, row in df_carte.iterrows():
            
            # D√©termination de la couleur selon le type
            couleur = couleurs.get(row[&#x27;Type&#x27;], &#x27;gray&#x27;)
            
            # Cr√©ation du contenu de la popup
            popup_html = f&quot;&quot;&quot;
            &lt;div style=&quot;font-family: Arial; width: 200px;&quot;&gt;
                &lt;b&gt;{row[&#x27;Site&#x27;]}&lt;/b&gt;&lt;br&gt;
                üìç {row[&#x27;Region&#x27;]}&lt;br&gt;
                üìÖ {int(row[&#x27;Annee&#x27;]) if pd.notna(row[&#x27;Annee&#x27;]) else &#x27;N/A&#x27;}&lt;br&gt;
                üèõÔ∏è {row[&#x27;Type&#x27;]}
            &lt;/div&gt;
            &quot;&quot;&quot;
            
            # Ajout du marqueur (comme dans le cours)
            folium.Marker(
                location=[row[&#x27;Latitude&#x27;], row[&#x27;Longitude&#x27;]],
                popup=folium.Popup(popup_html, max_width=300),
                icon=folium.Icon(color=couleur, icon=&#x27;info-sign&#x27;)
            ).add_to(carte)
        
        # Sauvegarde de la carte
        carte.save(nom_fichier)
        print(f&quot;‚úì Carte sauvegard√©e : {nom_fichier}&quot;)
        
        # Ouverture automatique dans le navigateur (comme dans le cours)
        webbrowser.open_new_tab(nom_fichier)
        print(f&quot;‚úì Carte ouverte dans le navigateur\n&quot;)
        
    except Exception as e:
        print(f&quot;‚úó Erreur lors de la cr√©ation de la carte : {e}\n&quot;)


# ============================================================================
# FONCTION PRINCIPALE
# ============================================================================

def main():
    &quot;&quot;&quot;
    Fonction principale orchestrant toutes les √©tapes du projet
    
    √âtapes :
    1. Connexion et scraping du site Wikipedia
    2. Extraction des donn√©es dans un DataFrame
    3. Conversion des coordonn√©es g√©ographiques
    4. Cr√©ation des visualisations (graphiques + carte)
    &quot;&quot;&quot;
    print(&quot;=&quot;*80)
    print(&quot; PROJET SA√â VCOD - SCRAPING DES SITES UNESCO EN FRANCE&quot;)
    print(&quot;=&quot;*80)
    print()
    
    # --- √âTAPE 1 : CONNEXION AU SITE ---
    soup = se_connecter_au_site(URL_WIKIPEDIA, HEADERS)
    
    if soup is None:
        print(&quot;‚ùå Impossible de continuer sans connexion&quot;)
        return
    
    # --- √âTAPE 2 : EXTRACTION DU TABLEAU ---
    tableau = extraire_tableau_sites(soup)
    
    if tableau is None:
        print(&quot;‚ùå Impossible de continuer sans le tableau&quot;)
        return
    
    # --- √âTAPE 3 : EXTRACTION DES DONN√âES ---
    donnees = extraire_donnees_sites(tableau)
    
    if donnees is None:
        print(&quot;‚ùå Impossible de continuer sans donn√©es&quot;)
        return
    
    # --- √âTAPE 4 : CR√âATION DU DATAFRAME ---
    print(&quot;üìã Cr√©ation du DataFrame pandas...&quot;)
    df = pd.DataFrame(donnees)
    print(f&quot;‚úì DataFrame cr√©√© : {len(df)} lignes √ó {len(df.columns)} colonnes\n&quot;)
    
    # Affichage d&#x27;un aper√ßu
    print(&quot;Aper√ßu des 3 premi√®res lignes :&quot;)
    print(df.head(3))
    print()
    
    # --- √âTAPE 5 : CONVERSION DES COORDONN√âES ---
    df = convertir_toutes_coordonnees(df)
    df = corriger_coordonnees_manquantes(df)
    
    # --- √âTAPE 6 : CR√âATION DES GRAPHIQUES ---
    print(&quot;=&quot;*80)
    print(&quot; VISUALISATIONS - GRAPHIQUES&quot;)
    print(&quot;=&quot;*80)
    print()
    
    creer_graphique_regions(df)
    creer_graphique_decennies(df)
    creer_graphique_types(df)
    
    # --- √âTAPE 7 : CR√âATION DE LA CARTE ---
    print(&quot;=&quot;*80)
    print(&quot; VISUALISATION - CARTE INTERACTIVE&quot;)
    print(&quot;=&quot;*80)
    print()
    
    creer_carte_interactive(df)
    
    # --- FIN ---
    print(&quot;=&quot;*80)
    print(&quot; ‚úÖ PROJET TERMIN√â AVEC SUCC√àS&quot;)
    print(&quot;=&quot;*80)
    print()
    print(f&quot;üìä Statistiques finales :&quot;)
    print(f&quot;   ‚Ä¢ {len(df)} sites UNESCO en France&quot;)
    print(f&quot;   ‚Ä¢ {df[&#x27;Latitude&#x27;].notna().sum()} sites g√©olocalis√©s&quot;)
    print(f&quot;   ‚Ä¢ {len(df[&#x27;Region&#x27;].unique())} r√©gions repr√©sent√©es&quot;)
    print(f&quot;   ‚Ä¢ {len(df[&#x27;Type&#x27;].unique())} types de sites&quot;)
    print()


# ============================================================================
# POINT D&#x27;ENTR√âE DU PROGRAMME
# ============================================================================

if __name__ == &quot;__main__&quot;:
    &quot;&quot;&quot;
    Point d&#x27;entr√©e : ce bloc s&#x27;ex√©cute uniquement si le script est lanc√© directement
    (pas si import√© comme module)
    &quot;&quot;&quot;
    main()

## ============================================================================
# FONCTION DE VISUALISATION - CARTE INTERACTIVE AVANC√âE
# ============================================================================

def verifier_coordonnees_france(latitude, longitude):
    &quot;&quot;&quot;
    V√©rifie si des coordonn√©es GPS sont situ√©es en France (m√©tropole ou DOM-TOM)
    
    Zones g√©ographiques couvertes :
    - France m√©tropolitaine : 41¬∞-51¬∞ N, -5¬∞-10¬∞ E
    - La R√©union : -25¬∞ √† -20¬∞ N, 55¬∞-60¬∞ E
    - Guadeloupe/Martinique : 14¬∞-18¬∞ N, -63¬∞ √† -60¬∞ E
    - Nouvelle-Cal√©donie : -23¬∞ √† -21¬∞ N, 164¬∞-168¬∞ E
    - Polyn√©sie fran√ßaise : -18¬∞ √† -8¬∞ N, -141¬∞ √† -138¬∞ E
    - TAAF : -50¬∞ √† -37¬∞ N, 50¬∞-78¬∞ E
    
    Param√®tres :
        latitude (float) : Latitude en degr√©s d√©cimaux
        longitude (float) : Longitude en degr√©s d√©cimaux
    
    Retourne :
        bool : True si les coordonn√©es sont en France, False sinon
    &quot;&quot;&quot;
    try:
        # V√©rification France m√©tropolitaine
        if 41 &lt;= latitude &lt;= 51 and -5 &lt;= longitude &lt;= 10:
            return True
        
        # V√©rification La R√©union
        if -25 &lt;= latitude &lt;= -20 and 55 &lt;= longitude &lt;= 60:
            return True
        
        # V√©rification Guadeloupe/Martinique
        if 14 &lt;= latitude &lt;= 18 and -63 &lt;= longitude &lt;= -60:
            return True
        
        # V√©rification Nouvelle-Cal√©donie
        if -23 &lt;= latitude &lt;= -21 and 164 &lt;= longitude &lt;= 168:
            return True
        
        # V√©rification Polyn√©sie fran√ßaise
        if -18 &lt;= latitude &lt;= -8 and -141 &lt;= longitude &lt;= -138:
            return True
        
        # V√©rification TAAF (Terres australes et antarctiques fran√ßaises)
        if -50 &lt;= latitude &lt;= -37 and 50 &lt;= longitude &lt;= 78:
            return True
        
        return False
        
    except Exception as e:
        print(f&quot;‚ö†Ô∏è  Erreur lors de la v√©rification des coordonn√©es : {e}&quot;)
        return False


def obtenir_configuration_type(type_site):
    &quot;&quot;&quot;
    Retourne la configuration visuelle (couleur et ic√¥ne) pour un type de site
    
    Param√®tres :
        type_site (str) : Type du site (&#x27;Culturel&#x27;, &#x27;Naturel&#x27;, ou &#x27;Mixte&#x27;)
    
    Retourne :
        dict : Dictionnaire avec &#x27;color&#x27; et &#x27;icon&#x27;
    &quot;&quot;&quot;
    # Configuration des couleurs et ic√¥nes par type de site
    configurations = {
        &#x27;Culturel&#x27;: {
            &#x27;color&#x27;: &#x27;#3498db&#x27;,      # Bleu
            &#x27;icon&#x27;: &#x27;fa-landmark&#x27;    # Ic√¥ne monument
        },
        &#x27;Naturel&#x27;: {
            &#x27;color&#x27;: &#x27;#27ae60&#x27;,      # Vert
            &#x27;icon&#x27;: &#x27;fa-tree&#x27;        # Ic√¥ne arbre
        },
        &#x27;Mixte&#x27;: {
            &#x27;color&#x27;: &#x27;#e67e22&#x27;,      # Orange
            &#x27;icon&#x27;: &#x27;fa-mountain-sun&#x27; # Ic√¥ne montagne/soleil
        }
    }
    
    # Retour de la config ou config par d√©faut si type inconnu
    return configurations.get(type_site, {
        &#x27;color&#x27;: &#x27;#95a5a6&#x27;,       # Gris
        &#x27;icon&#x27;: &#x27;fa-map-marker&#x27;   # Marqueur standard
    })


def creer_popup_html(row, config_couleur):
    &quot;&quot;&quot;
    Cr√©e le contenu HTML styl√© pour la popup d&#x27;un marqueur
    
    Param√®tres :
        row (Series) : Ligne du DataFrame contenant les infos du site
        config_couleur (dict) : Configuration de couleur et ic√¥ne
    
    Retourne :
        str : Code HTML de la popup
    &quot;&quot;&quot;
    popup_html = f&quot;&quot;&quot;
    &lt;div style=&quot;font-family: &#x27;Segoe UI&#x27;, Tahoma, sans-serif; width: 250px;&quot;&gt;
        &lt;h4 style=&quot;color: {config_couleur[&#x27;color&#x27;]}; 
                   margin: 0 0 10px 0; 
                   font-size: 16px; 
                   border-bottom: 2px solid {config_couleur[&#x27;color&#x27;]}; 
                   padding-bottom: 5px;&quot;&gt;
            &lt;i class=&quot;fa {config_couleur[&#x27;icon&#x27;]}&quot; style=&quot;margin-right: 8px;&quot;&gt;&lt;/i&gt;
            {row[&#x27;Site&#x27;]}
        &lt;/h4&gt;
        
        &lt;p style=&quot;margin: 5px 0; color: #555; font-size: 13px;&quot;&gt;
            &lt;i class=&quot;fa fa-map-pin&quot; style=&quot;color: {config_couleur[&#x27;color&#x27;]}; margin-right: 5px;&quot;&gt;&lt;/i&gt;
            &lt;strong&gt;R√©gion:&lt;/strong&gt; {row[&#x27;Region&#x27;]}
        &lt;/p&gt;
        
        &lt;p style=&quot;margin: 5px 0; color: #555; font-size: 13px;&quot;&gt;
            &lt;i class=&quot;fa fa-tag&quot; style=&quot;color: {config_couleur[&#x27;color&#x27;]}; margin-right: 5px;&quot;&gt;&lt;/i&gt;
            &lt;strong&gt;Type:&lt;/strong&gt; {row[&#x27;Type&#x27;]}
        &lt;/p&gt;
        
        &lt;p style=&quot;margin: 5px 0; color: #555; font-size: 13px;&quot;&gt;
            &lt;i class=&quot;fa fa-calendar&quot; style=&quot;color: {config_couleur[&#x27;color&#x27;]}; margin-right: 5px;&quot;&gt;&lt;/i&gt;
            &lt;strong&gt;Inscrit en:&lt;/strong&gt; {int(row[&#x27;Annee&#x27;]) if pd.notna(row[&#x27;Annee&#x27;]) else &#x27;N/A&#x27;}
        &lt;/p&gt;
    &lt;/div&gt;
    &quot;&quot;&quot;
    
    return popup_html


def creer_legende_html(dataframe):
    &quot;&quot;&quot;
    Cr√©e le code HTML de la l√©gende affich√©e sur la carte
    
    Param√®tres :
        dataframe (DataFrame) : DataFrame complet pour compter les sites par type
    
    Retourne :
        str : Code HTML de la l√©gende
    &quot;&quot;&quot;
    # Comptage des sites par type
    nb_culturel = len(dataframe[dataframe[&#x27;Type&#x27;] == &#x27;Culturel&#x27;])
    nb_naturel = len(dataframe[dataframe[&#x27;Type&#x27;] == &#x27;Naturel&#x27;])
    nb_mixte = len(dataframe[dataframe[&#x27;Type&#x27;] == &#x27;Mixte&#x27;])
    nb_total = len(dataframe.dropna(subset=[&#x27;Latitude&#x27;, &#x27;Longitude&#x27;]))
    
    legende_html = f&quot;&quot;&quot;
    &lt;div style=&quot;position: fixed; 
                top: 10px; 
                right: 10px; 
                width: 200px; 
                background-color: white; 
                border: 2px solid #ddd;
                border-radius: 10px;
                padding: 15px;
                font-family: &#x27;Segoe UI&#x27;, Tahoma, sans-serif;
                font-size: 14px;
                box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                z-index: 9999;&quot;&gt;
        
        &lt;!-- En-t√™te de la l√©gende --&gt;
        &lt;h4 style=&quot;margin: 0 0 12px 0; 
                   color: #2c3e50; 
                   font-size: 16px; 
                   border-bottom: 2px solid #3498db; 
                   padding-bottom: 8px;&quot;&gt;
            &lt;i class=&quot;fa fa-layer-group&quot; style=&quot;margin-right: 8px;&quot;&gt;&lt;/i&gt;L√©gende
        &lt;/h4&gt;
        
        &lt;!-- Type Culturel --&gt;
        &lt;div style=&quot;margin: 8px 0;&quot;&gt;
            &lt;i class=&quot;fa fa-landmark&quot; style=&quot;color: #3498db; margin-right: 8px;&quot;&gt;&lt;/i&gt;
            &lt;span style=&quot;color: #555;&quot;&gt;Culturel ({nb_culturel})&lt;/span&gt;
        &lt;/div&gt;
        
        &lt;!-- Type Naturel --&gt;
        &lt;div style=&quot;margin: 8px 0;&quot;&gt;
            &lt;i class=&quot;fa fa-tree&quot; style=&quot;color: #27ae60; margin-right: 8px;&quot;&gt;&lt;/i&gt;
            &lt;span style=&quot;color: #555;&quot;&gt;Naturel ({nb_naturel})&lt;/span&gt;
        &lt;/div&gt;
        
        &lt;!-- Type Mixte --&gt;
        &lt;div style=&quot;margin: 8px 0;&quot;&gt;
            &lt;i class=&quot;fa fa-mountain-sun&quot; style=&quot;color: #e67e22; margin-right: 8px;&quot;&gt;&lt;/i&gt;
            &lt;span style=&quot;color: #555;&quot;&gt;Mixte ({nb_mixte})&lt;/span&gt;
        &lt;/div&gt;
        
        &lt;!-- S√©parateur --&gt;
        &lt;hr style=&quot;border: none; border-top: 1px solid #ddd; margin: 12px 0;&quot;&gt;
        
        &lt;!-- Total --&gt;
        &lt;div style=&quot;text-align: center; color: #7f8c8d; font-size: 12px;&quot;&gt;
            &lt;strong&gt;Total: {nb_total} sites&lt;/strong&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &quot;&quot;&quot;
    
    return legende_html


def creer_carte_interactive(dataframe, nom_fichier=&#x27;carte_unesco_france.html&#x27;):
    &quot;&quot;&quot;
    Cr√©e une carte interactive avanc√©e avec Folium montrant tous les sites UNESCO
    
    Fonctionnalit√©s :
    - Marqueurs color√©s et personnalis√©s par type de site
    - Popups avec informations d√©taill√©es
    - L√©gende interactive
    - Filtrage g√©ographique (France m√©tropolitaine + DOM-TOM)
    - Bouton plein √©cran
    - Mini-carte de navigation
    - Style moderne CartoDB Positron
    
    Param√®tres :
        dataframe (DataFrame) : DataFrame avec colonnes Latitude, Longitude, Site, Type, etc.
        nom_fichier (str) : Nom du fichier HTML √† g√©n√©rer (d√©faut: &#x27;carte_unesco_france.html&#x27;)
    &quot;&quot;&quot;
    try:
        print(&quot;üó∫Ô∏è  Cr√©ation de la carte interactive avanc√©e...&quot;)
        
        # Import du module plugins pour fonctionnalit√©s avanc√©es
        from folium import plugins
        
        # --- √âTAPE 1 : FILTRAGE DES DONN√âES ---
        # On ne garde que les sites avec coordonn√©es valides
        df_carte = dataframe.dropna(subset=[&#x27;Latitude&#x27;, &#x27;Longitude&#x27;]).copy()
        print(f&quot;   ‚Üí {len(df_carte)} sites avec coordonn√©es valides&quot;)
        
        # --- √âTAPE 2 : CR√âATION DE LA CARTE DE BASE ---
        # Carte moderne avec style CartoDB Positron (plus clair et √©l√©gant)
        carte = folium.Map(
            location=[46.6, 2.5],           # Centre de la France
            zoom_start=6,                    # Niveau de zoom initial
            tiles=&#x27;CartoDB positron&#x27;,        # Style de carte moderne
            control_scale=True               # Affichage de l&#x27;√©chelle
        )
        print(&quot;   ‚Üí Carte de base cr√©√©e avec style CartoDB Positron&quot;)
        
        # --- √âTAPE 3 : AJOUT DES MARQUEURS ---
        marqueurs_ajoutes = 0
        marqueurs_ignores = 0
        
        for index, row in df_carte.iterrows():
            lat = row[&#x27;Latitude&#x27;]
            lon = row[&#x27;Longitude&#x27;]
            
            # V√©rification que le site est bien en France
            if not verifier_coordonnees_france(lat, lon):
                print(f&quot;   ‚ö†Ô∏è  Hors France : {row[&#x27;Site&#x27;]} ({lat:.2f}, {lon:.2f})&quot;)
                marqueurs_ignores += 1
                continue
            
            # R√©cup√©ration de la configuration (couleur/ic√¥ne) selon le type
            config = obtenir_configuration_type(row[&#x27;Type&#x27;])
            
            # Cr√©ation du contenu HTML de la popup
            popup_html = creer_popup_html(row, config)
            
            # Cr√©ation et ajout du marqueur sur la carte
            folium.Marker(
                location=[lat, lon],
                popup=folium.Popup(popup_html, max_width=300),
                tooltip=f&quot;&lt;b&gt;{row[&#x27;Site&#x27;]}&lt;/b&gt;&quot;,  # Info-bulle au survol
                icon=folium.Icon(
                    color=&#x27;white&#x27;,               # Fond du marqueur
                    icon_color=config[&#x27;color&#x27;],  # Couleur de l&#x27;ic√¥ne
                    icon=config[&#x27;icon&#x27;],         # Ic√¥ne Font Awesome
                    prefix=&#x27;fa&#x27;                  # Pr√©fixe pour Font Awesome
                )
            ).add_to(carte)
            
            marqueurs_ajoutes += 1
        
        print(f&quot;   ‚Üí {marqueurs_ajoutes} marqueurs ajout√©s&quot;)
        if marqueurs_ignores &gt; 0:
            print(f&quot;   ‚Üí {marqueurs_ignores} marqueurs ignor√©s (hors France)&quot;)
        
        # --- √âTAPE 4 : AJOUT DE LA L√âGENDE ---
        legende_html = creer_legende_html(dataframe)
        carte.get_root().html.add_child(folium.Element(legende_html))
        print(&quot;   ‚Üí L√©gende ajout√©e&quot;)
        
        # --- √âTAPE 5 : AJOUT DES PLUGINS INTERACTIFS ---
        
        # Plugin 1 : Bouton plein √©cran
        plugins.Fullscreen(
            position=&#x27;topleft&#x27;,              # Position en haut √† gauche
            title=&#x27;Plein √©cran&#x27;,
            title_cancel=&#x27;Quitter le plein √©cran&#x27;,
            force_separate_button=True
        ).add_to(carte)
        print(&quot;   ‚Üí Plugin plein √©cran ajout√©&quot;)
        
        # Plugin 2 : Mini-carte de navigation
        plugins.MiniMap(
            toggle_display=True              # Possibilit√© de masquer/afficher
        ).add_to(carte)
        print(&quot;   ‚Üí Mini-carte de navigation ajout√©e&quot;)
        
        # --- √âTAPE 6 : SAUVEGARDE ET OUVERTURE ---
        carte.save(nom_fichier)
        print(f&quot;‚úì Carte sauvegard√©e : {nom_fichier}&quot;)

        # Ouverture dans le navigateur avec chemin absolu
        chemin_absolu = os.path.abspath(nom_fichier)
        webbrowser.open(&#x27;file://&#x27; + chemin_absolu)
        print(f&quot;‚úì Carte ouverte dans le navigateur\n&quot;)
        
    except ImportError as e:
        print(f&quot;‚úó Erreur : Module manquant - {e}&quot;)
        print(&quot;   Installez folium avec : pip install folium\n&quot;)
    except Exception as e:
        print(f&quot;‚úó Erreur lors de la cr√©ation de la carte : {e}\n&quot;)</code></pre>
        </div>
    </div>
    
    <div class="success-message" id="successMessage">
        <i class="fa-solid fa-check-circle"></i>
        <span>Code copi√© dans le presse-papier !</span>
    </div>
    
    <script>
        // Initialiser la coloration syntaxique
        hljs.highlightAll();
        
        // Fonction pour copier le code
        function copyCode() {
            const codeElement = document.querySelector('code');
            const textToCopy = codeElement.textContent;
            
            navigator.clipboard.writeText(textToCopy).then(() => {
                // Afficher le message de succ√®s
                const message = document.getElementById('successMessage');
                message.classList.add('show');
                
                // Masquer apr√®s 3 secondes
                setTimeout(() => {
                    message.classList.remove('show');
                }, 3000);
            }).catch(err => {
                alert('Erreur lors de la copie : ' + err);
            });
        }
    </script>
</body>
</html>